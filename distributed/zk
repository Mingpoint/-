分布式特点：
1.分布性
2.对等性
3.并发性
4.缺乏全局时钟
5.故障
分布式问题：
1、通行异常：
2、网络分区：部分节点之间能通信正常，而另一些节点异常，可能会出现分布式事务问题
3、三态：分布式系统每一次请求与响应，存在三种状态：成功，失败，超时
4、节点故障：分布式节点机器出现宕机想象

事务：由一系列中数据进行访问与更新的操作所组成的一个程序执行逻辑单元，狭义上的事务特性指数据库事务。
一方面，多个应用程序并发访问数据库时，事务可以在这些应用之间提供一个隔离方法，以防止pichi的操作互相干扰。
另一方面，事务为数据库操作序列提供一个从失败中恢复到正常状态的方法，同时提供数据库即使在异常状态下。


CAP理论：
    一个系统中不可能同时满足 一致性：C(Consistency),可用性(A:Availability),容错性(P:Partition tolerance),
最多只能满足其中两个
C 一致性：在分布式系统下，数据在多个副本之间能保持一致性。
A 可用性：系统提供的服务必须一直处于可用状态，对于用户的每一个请求总是能够在有限时间内响应结果
    '有限时间'：对于一个请求，系统必须在指定的时间内返回对应的结果，如果超出了这个范围，则认为系统不可用。
    '返回结果'：返回结果是可用性的一个指标。
P 容错性：在某一个网络分区，或者是某一个节点故障，系统任然保证对外提供满足一致性和可用性的服务，除非整个网络都异常。

BASE理论：
BASE是 Base Available（基本可用），Soft state（软状态），Eventually consistent (最终一致性)：
其核心思想：即使无法做到强一致性，但每一个应用都可以根据自身特点的业务特点，采用适当的方式来是系统达到一致。
    1.Base Available（基本可用）：分布式系统在出现不可预知的故障时候，允许损失一部分可用性
        响应时间上的损失
        功能上的损失
    2.Soft state（软状态）：允许数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许
    系统在不同的数据副本之间进行数据同步的过程存在延时。
    3.最终一致性：系统中的所有数据副本，在进过一段时间的同步后，最终能达到一个一致的状态。


zk应用场景：发布/订阅（配置中心），负载均衡，命名服务，分布式协调/通知，集群管理，分布式锁，分布式队列
zk目标：提供一个高性能，高可用，且具有严格的顺序访问控制能力。
顺序访问：对于来自客户端的更新请求，zk都会分配一个全局唯一的递增编号，这个编号反应所有事物的顺序。

ZAB（zookeeper Atomic Broadcast）zookeeper原子广播协议
    广播模式：广播模式是一个原子协议，类似二阶段提交过程。Leader服务器会为其生成对应的事物Proposal,并将
其发送给集群中其他的所有机器，然后收集选票，提交事物。在没有二阶段中的中断事物。相当于简化了二阶段提交，但是却
无法处理Leader 服务器崩溃产生的数据不一致问题。因此ZAB协议会进入崩溃模式。

    zookeeper采用ZAB协议的核心就是只要有一台服务器提交了proposal，就要确保所有的服务器最终都能正确提交proposal。
    这也是CAP/BASE最终实现一致性的一个体现
    leader服务器与每个follower之间都有一个单独的队列进行收发消息，使用队列消息可以做到异步解耦。
    leader和follower之间只要往队列中发送了消息即可。如果使用同步方式容易引起阻塞。性能上要下降很多。

    广播模式是基于FIFO特性的TCP网络通信的，因此可以保证消息广播的过程中消息接受与发送的顺序性。
    广播模式的具体步骤：
        客户端发起一个写操作请求
        1. Leader服务器将客户端的request请求转化为事物proposal提案，
        同时为每个proposal分配一个全局唯一的ID，即ZXID。
        2. leader服务器与每个follower之间都有一个队列，leader将消息发送到该队列
        3. follower机器从队列中取出消息处理完(写入本地事物日志中)毕后，向leader服务器发送ACK确认。
        4. leader服务器收到半数以上的follower的ACK后，即认为可以发送commit
        5. leader向所有的follower服务器发送commit消息。


    崩溃模式：ZAB协议崩溃恢复要求满足如下2个要求
        1.确保已经被leader提交的proposal必须最终被所有的follower服务器提交。
        2. 确保丢弃已经被leader出的但是没有被提交的proposal。

        新选举出来的leader不能包含未提交的proposal，即新选举的leader必须都是已经提交了的proposal的follower服务器
        节点。同时，新选举的leader节点中含有最高的ZXID。这样做的好处就是可以避免了leader服务器检查proposal的
        提交和丢弃工作。

    leader服务器发生崩溃时分为如下场景：
        1. leader在提出proposal时未提交之前崩溃，则经过崩溃恢复之后，新选举的leader一定不能是刚才的leader。
        因为这个leader存在未提交的proposal。
        2 leader在发送commit消息之后，崩溃。即消息已经发送到队列中。经过崩溃恢复之后，参与选举的follower服务器
        (刚才崩溃的leader有可能已经恢复运行，也属于follower节点范畴)中有的节点已经是消费了队列中所有的commit消息。
        即该follower节点将会被选举为最新的leader。剩下动作就是数据同步过程。

    数据同步：
    1.在zookeeper集群中新的leader选举成功之后，leader会将自身的提交的最大proposal的事物ZXID发送给其他的
    follower节点。follower节点会根据leader的消息进行回退或者是数据同步操作。最终目的要保证集群中所有节点的数据
    副本保持一致。
    2.数据同步完之后，zookeeper集群如何保证新选举的leader分配的ZXID是全局唯一呢？这个就要从ZXID的设计谈起。
    2.1 ZXID是一个长度64位的数字，其中低32位是按照数字递增，即每次客户端发起一个proposal,
    低32位的数字简单加1。高32位是leader周期的epoch编号，至于这个编号如何产生(我也没有搞明白)，
    每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的epoch编号，进行加1，
    再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的

ZAB协议原理
ZAB协议要求每个leader都要经历三个阶段，即发现，同步，广播。
1.发现：即要求zookeeper集群必须选择出一个leader进程，同时leader会维护一个follower可用列表。
将来客户端可以这follower中的节点进行通信。
2.同步：leader要负责将本身的数据与follower完成同步，做到多副本存储。这样也是体现了CAP中高可用和分区容错。
follower将队列中未处理完的请求消费完成后，写入本地事物日志中。
3.广播：leader可以接受客户端新的proposal请求，将新的proposal请求广播给所有的follower。

Leader选举：
首先给出几个名词定义：
（1）Serverd：在配置server时，给定的服务器的标示id。
（2）Zxid:服务器在运行时产生的数据id，zxid越大，表示数据越新。
（3）Epoch：选举的轮数，即逻辑时钟。随着选举的轮数++
（4）Server状态：LOOKING,FOLLOWING,OBSERVING,LEADING
步骤：
一、  Server刚启动（宕机恢复或者刚启动）准备加入集群，此时读取自身的zxid等信息。
二、  所有Server加入集群时都会推荐自己为leader，然后将（leader id 、 zixd 、 epoch）作为广播信息，
广播到集群中所有的服务器(Server)。然后等待集群中的服务器返回信息。
三、  收到集群中其他服务器返回的信息，此时要分为两类：该服务器处于looking状态，或者其他状态。
（1）服务器处于looking状态
    首先判断逻辑时钟 Epoch:
        a)如果接收到Epoch大于自己目前的逻辑时钟（说明自己所保存的逻辑时钟落伍了）。更新本机逻辑时钟Epoch，
        同时 Clear其他服务发送来的选举数据（这些数据已经OUT了）。然后判断是否需要更新当前自己的
        选举情况（一开始选择的leader id 是自己）
        判断规则rules judging：保存的zxid最大值和leader Serverid来进行判断的。
        先看数据zxid,数据zxid大者胜出;其次再判断leaderServerid,
         leader Serverid大者胜出；然后再将自身最新的选举结果
         (也就是上面提到的三种数据（leader Serverid，Zxid，Epoch）广播给其他server)

        b)如果接收到的Epoch小于目前的逻辑时钟。说明对方处于一个比较OUT的选举轮数，
        这时只需要将自己的 （leader Serverid，Zxid，Epoch）发送给他即可。

        c)如果接收到的Epoch等于目前的逻辑时钟。再根据a)中的判断规则，
        将自身的最新选举结果广播给其他 server。

    同时Server还要处理2种情况：

        a)如果Server接收到了其他所有服务器的选举信息，那么则根据这些选举信息确定自己的状态（Following,Leading），
        结束Looking，退出选举。
        b)即使没有收到所有服务器的选举信息，也可以判断一下根据以上过程之后最新的选举leader是不是得到了超过
        半数以上服务器的支持，如果是则尝试接受最新数据，倘若没有最新的数据到来，说明大家都已经默认了这个结果,
        同样也设置角色退出选举过程。

（2）服务器处于其他状态（Following, Leading）
    a)     如果逻辑时钟Epoch相同,将该数据保存到recvset,如果所接收服务器宣称自己是leader,
    那么将判断是不是有半数以上的服务器选举它,如果是则设置选举状态退出选举过程
    b)     否则这是一条与当前逻辑时钟不符合的消息，那么说明在另一个选举过程中已经有了选举结果，
    于是将该选举结果加入到outofelection集合中，再根据outofelection来判断是否可以结束选举,
    如果可以也是保存逻辑时钟，设置选举状态，退出选举过程。

选举流程简述
目前有5台服务器，每台服务器均没有数据，它们的编号分别是1,2,3,4,5,按编号依次启动，它们的选择举过程如下：
1.服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。
2.服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，
所以两个服务器的状态依然是LOOKING。
3.服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，
此时投票数正好大于半数，所以服务器3成为领导者，服务器1,2成为小弟。
4.服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，
所以服务器4只能成为小弟。
5.服务器5启动，后面的逻辑同服务器4成为小弟。

ZAB与Paxos 区别：
ZAB协议主要构件一个高可用的分布式的主备系统，Paxos协议构件一个分布式一致性状态机系统。

zk集群如何通信：

