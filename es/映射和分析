分析 包含下面的过程：
    首先，将一块文本分成适合于倒排索引的独立的 词条 ，
    之后，将这些词条统一化为标准格式以提高它们的“可搜索性”，或者 recall

字符过滤器
    首先，字符串按顺序通过每个 字符过滤器 。他们的任务是在分词前整理字符串。一个字符过滤器可以用来去掉HTML，或者将 & 转化成 and
分词器
    其次，字符串被 分词器 分为单个的词条。一个简单的分词器遇到空格和标点的时候，可能会将文本拆分成词条。
Token 过滤器
    最后，词条按顺序通过每个 token 过滤器 。这个过程可能会改变词条（例如，小写化 Quick ），删除词条（例如， 像 a， and， the 等无用词），
    或者增加词条（例如，像 jump 和 leap 这种同义词）

Elasticsearch 支持如下简单域类型：
    字符串: string
    整数 : byte, short, integer, long
    浮点数: float, double
    布尔型: boolean
    日期: date

Elasticsearch 使用的查询语言（DSL）拥有一套查询组件，这些组件可以以无限组合的方式进行搭配
这套组件可以在以下两种情况下使用：过滤情况（filtering context）和查询情况
match 查询
    {
        "query": {
            "match": {
                "age": 26
            }
        }
    }
    如果你在一个全文字段上使用 match 查询，在执行查询前，它将用正确的分析器去分析查询字符串
    如果在一个精确值的字段上使用它，例如数字、日期、布尔或者一个 not_analyzed 字符串字段，那么它将会精确匹配给定的值
multi_match 查询
    {
        "multi_match": {
            "query":    "full text search",
            "fields":   [ "title", "body" ]
        }
    }
    multi_match 查询可以在多个字段上执行相同的 match 查询

range 查询找出那些落在指定区间内的数字或者时间
    {
        "range": {
            "age": {
                "gte":  20,
                "lt":   30
            }
        }
    }

被允许的操作符如下：
    gt 大于
    gte 大于等于
    lt 小于
    lte 小于等于

term 查询被用于精确值匹配，这些精确值可能是数字、时间、布尔或者那些 not_analyzed 的字符串,相当于 '=='
terms 查询和 term 查询一样，但它允许你指定多值进行匹配。如果这个字段包含了指定值中的任何一个值，那么这个文档满足条件 ,相当于 'in'

exists 查询和 missing 查询被用于查找那些指定字段中有值 (exists) 或无值 (missing) 的文档。
这与SQL中的 IS_NULL (missing) 和 NOT IS_NULL (exists) 在本质上具有共性


你可以用 bool 查询来实现你的需求。这种查询将多查询组合在一起，成为用户自己想要的布尔查询。它接收以下参数：
    must 文档 必须 匹配这些条件才能被包含进来。
    must_not 文档 必须不 匹配这些条件才能被包含进来。
    should 如果满足这些语句中的任意语句，将增加 _score ，否则，无任何影响。它们主要用于修正每个文档的相关性得分。
    filter 必须 匹配，但它以不评分、过滤模式来进行。这些语句对评分没有贡献，只是根据过滤标准来排除或包含文档

为了找出 查询不合法的原因，可以将 explain 参数 加到查询字符串中：
    GET /gb/tweet/_validate/query?explain
    {
       "query": {
          "tweet" : {
             "match" : "really powerful"
          }
       }
    }

Elasticsearch 的相似度算法被定义为检索词频率/反向文档频率， TF/IDF ，包括以下内容：
    检索词频率
        检索词在该字段出现的频率？出现频率越高，相关性也越高。 字段中出现过 5 次要比只出现过 1 次的相关性高。
    反向文档频率
        每个检索词在索引中出现的频率？频率越高，相关性越低。检索词出现在多数文档中会比出现在少数文档中的权重更低。
    字段长度准则
        字段的长度是多少？长度越长，相关性越低。 检索词出现在一个短的 title 要比同样的词出现在一个长的 content 字段权重更大


搜索被执行成一个两阶段过程，我们称之为 query then fetch
    查询阶段包含以下三个步骤:
        客户端发送一个 search 请求到 Node 3 ， Node 3 会创建一个大小为 from + size 的空优先队列。
        Node 3 将查询请求转发到索引的每个主分片或副本分片中。每个分片在本地执行查询并添加结果到大小为 from + size 的本地有序优先队列中。
        每个分片返回各自优先队列中所有文档的 ID 和排序值给协调节点，也就是 Node 3 ，它合并这些值到自己的优先队列中来产生一个全局排序后的结果列表
    取回阶段由以下步骤构成：
        协调节点辨别出哪些文档需要被取回并向相关的分片提交多个 GET 请求。
        每个分片加载并 丰富 文档，如果有需要的话，接着返回文档给协调节点。
        一旦所有的文档都被取回了，协调节点返回结果给客户端

深分页（Deep Pagination）
    先查后取的过程支持用 from 和 size 参数分页，但是这是 有限制的 。
    要记住需要传递信息给协调节点的每个分片必须先创建一个 from + size 长度的队列，协调节点需要根据 number_of_shards * (from + size) 排序文档，
    来找到被包含在 size 里的文档。
    取决于你的文档的大小，分片的数量和你使用的硬件，给 10,000 到 50,000 的结果文档深分页（ 1,000 到 5,000 页）是完全可行的。
    但是使用足够大的 from 值，排序过程可能会变得非常沉重，使用大量的CPU、内存和带宽。因为这个原因，我们强烈建议你不要使用深分页。
    实际上， “深分页” 很少符合人的行为。当2到3页过去以后，人会停止翻页，并且改变搜索标准。
    会不知疲倦地一页一页的获取网页直到你的服务崩溃的罪魁祸首一般是机器人或者web spider。
    如果你 确实 需要从你的集群取回大量的文档，你可以通过用 scroll 查询禁用排序使这个取回行为更有效率，我们会在 later in this chapter 进行讨论。



在内部，Elasticsearch 会在运行非评分查询的时执行多个操作：
    查找匹配文档.
        term 查询在倒排索引中查找 XHDK-A-1293-#fJ3 然后获取包含该 term 的所有文档。本例中，只有文档 1 满足我们要求。
    创建 bitset.
        过滤器会创建一个 bitset （一个包含 0 和 1 的数组），它描述了哪个文档会包含该 term 。匹配文档的标志位是 1 。
        本例中，bitset 的值为 [1,0,0,0] 。在内部，它表示成一个 "roaring bitmap"，可以同时对稀疏或密集的集合进行高效编码。
    迭代 bitset(s)
        一旦为每个查询生成了 bitsets ，Elasticsearch 就会循环迭代 bitsets 从而找到满足所有过滤条件的匹配文档的集合。
        执行顺序是启发式的，但一般来说先迭代稀疏的 bitset （因为它可以排除掉大量的文档）。
    增量使用计数.
        Elasticsearch 能够缓存非评分查询从而获取更快的访问，但是它也会不太聪明地缓存一些使用极少的东西。非评分计算因为倒排索引已经足够快了，
        所以我们只想缓存那些我们 知道 在将来会被再次使用的查询，以避免资源的浪费。
        为了实现以上设想，Elasticsearch 会为每个索引跟踪保留查询使用的历史状态。如果查询在最近的 256 次查询中会被用到，那么它就会被缓存到内存中。
        当 bitset 被缓存后，缓存会在那些低于 10,000 个文档（或少于 3% 的总索引数）的段（segment）中被忽略。这些小的段即将会消失，
        所以为它们分配缓存是一种浪费。


组合过滤器
前面的两个例子都是单个过滤器（filter）的使用方式。 在实际应用中，我们很有可能会过滤多个值或字段。比方说，怎样用 Elasticsearch 来表达下面的 SQL ？

SELECT product
FROM   products
WHERE  (price = 20 OR productID = "XHDK-A-1293-#fJ3")
  AND  (price != 30)
这种情况下，我们需要 bool （布尔）过滤器。 这是个 复合过滤器（compound filter） ，它可以接受多个其他过滤器作为参数，并将这些过滤器结合成各式各样的布尔（逻辑）组合。

布尔过滤器
    一个 bool 过滤器由三部分组成：
    {
       "bool" : {
          "must" :     [],
          "should" :   [],
          "must_not" : [],
       }
    }
    must 所有的语句都 必须（must） 匹配，与 AND 等价。
    must_not 所有的语句都 不能（must not） 匹配，与 NOT 等价。
    should 至少有一个语句要匹配，与 OR 等价。


