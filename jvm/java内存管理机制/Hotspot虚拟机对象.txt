1.对象创建

    指针碰撞(Bump the Pointer):假设所有的Java堆内存是绝对的规整，所有用过的内存放在一边，未用过的内存放在另一边，中间
    放一个指针作为指示器，那分配内存就只需要把指针向空闲另一边移动。

    空闲列表(Free List):虚拟机维护一个列表记录空闲内存空间，在分配内存时从列表中找出一块足够大的内存分配给对象实例。

    并发解决方案:给A线程的A对象分配内存空间，即使时指针还没来得及修改，已经分配给B线程的B对象。
    1.对分配内存空间的操作进行同步处理----实际上虚拟机用CAS配上失败重试机制的方式保证更新操作的原子操作
    2.把内存的分配的动作按照线程划分在不同的空间内进行，即每个线程预先从Java堆中分配一块小内存，称为
    本地线程分配缓冲(Thread Local Allocation Buffer,TLAB),虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数设置

--------------------------------------------------------------------------------------------------------------

2.对象的内存布局
    对象在内存中的分布:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)

    HotSpot虚拟机对象头分为两个部分：一部分用于存储对象自身的运行数据,如哈希码，GC分代年龄，锁状态标志，偏向线程ID等。
    另一部分是类型指针，即指向对象的类元数据的指针，虚拟机通过这个指针来确定这个对象属于那个类的实例(如果是数组，则还
    需要一块内存来记录数组的大小)

--------------------------------------------------------------------------------------------------------------

3.对象的访问定位
    访问方式：使用句柄和直接使用指针
    使用句柄：在Java堆上需要划分出一块内存作为句柄池，方法栈上存储的引用就是对象的句柄地址，句柄中包含了对象实例数据
    与类型数据各自的具体地址信息

    直接使用指针：方法栈上的引用存储的就是对象的地址，但是必须要考虑在Java堆上设置类型数据



