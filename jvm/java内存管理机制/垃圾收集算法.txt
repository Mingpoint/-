1.标记-清除算法(Mark-Sweep):
    算法分为标记和清除两个阶段：首先标记需要回收的对象，然后统一回收。
    不足：一效率问题，标记和清除两个过程的效率不高；另一个时空间问题，标记清除之后会产生大量的不连续内存碎片。

2.复制算法(Coping)：
    可以按照内存大小分成大小相等的两块，每次只使用其中的一块。当这块用完了，就将还还存活的对象复制到另一块上，然后在清除
    这块上的内存空间；这样每次都是对其中的一半内存进行处理，不用考虑内存碎片等复杂情况，实现简单，高效。
    不足：直接把内存缩小为原来的一半。

3.标记-整理算法(Mark-Compact)：
    标记与标记-清除过程一样的，整理则是让所有活着的对象向一端移动，然后直接清除端边界以外的内存空间

4.分代回收算法(Generational Collection):
    将Java堆分成新生代与老生代，永久代(java7之后取消了)
    新生代包含Eden+Survivor,Survivor分为From和To，内存回收时，如果用的时复制算法，把From里面的对象实例复制到To里面，
    当经过一次或者多次GC之后，存活下来的对象会被移动到老年区，当JVM内存不够用时，会触发Full GC，清理JVM老年区

    当新生区满了之后会触发YGC,先把存活的对象放到其中一个Survivor区，然后进行垃圾清理。
    因为如果仅仅清理需要删除的对象，这样会导致内存碎片，因此一般会把Eden 进行完全的清理，然后整理内存。那么下次GC 的时候，
    就会使用下一个Survive，这样循环使用。如果有特别大的对象，新生代放不下，
    就会使用老年代的担保，直接放到老年代里面。因为JVM 认为，一般大对象的存
    活时间一般比较久远
---------------------------------------------------------------------------------------------------------------------
minor GC :一般是在新生代中发生，即新生区内存满了，就会发生。
Full GC ：一般是在老生代中发生。

