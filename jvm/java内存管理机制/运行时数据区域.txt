运行时数据区：

1.程序计数器(线程私有)：
    一块较小的内存空间，它可以看作当前线程执行的字节码的行号指示器。
    字节码解释器工工作就是通过改变程序计数器的值来选取下一条需要执行的指令，分支，
    循环，异常，线程恢复等都需程序计数器来完成

--------------------------------------------------------------------------------------------------

2.java虚拟机栈(java virtual machine stacks)(线程私有)
    java虚拟机栈描述java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(stack frame),用于存储
    局部变量表，操作数栈，动态链接，方法出口等信息；方法执行过程就是对应一个栈帧从入栈到出栈的过程。
在java虚拟机规范中：
    1.如果线程的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常
    2.如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常

--------------------------------------------------------------------------------------------------
3.本地方法栈：
    与java虚拟机类似，只不过本地方法栈服务于Native方法服务，java虚拟机栈服务于java方法，一样
    也会抛出StackOverflowError异常和抛出OutOfMemoryError异常

--------------------------------------------------------------------------------------------------
4.堆(java heap)(线程共享)：
    此内存唯一目的就是存放对象实例
    java堆是垃圾回收器管理的主要区域，因此很多时候也被称作'GC堆'；

    从内存回收角度上看，现代的收集器基本都采用分代回收算法
    Java堆细分：新生代和老生代，再细分Eden空间，From Survivor空间，To Survivor空间。

    从内存分配的角度上看，线程共享的Java堆可能划分出多个
    线程私有的分配缓冲区(Thread Local Allocation Buffer,TLAB)

在Java虚拟机规范中：
    所有对象实例和数组都要在堆上分配
    Java堆上的内存可以处于物理上是不连续，只要逻辑上是连续的即可；在实现上，既可以实现成固定大小，
    也可以动态扩展的，不过当前的主流的虚拟机都是按照可扩展来实现的(通过-Xmx和-Xms控制)
    如果堆上没有内存完成分配的实例，并且不能扩展时抛出OutOfMemoryError异常。

--------------------------------------------------------------------------------------------------
5.方法区(Method Area)(线程共享)：
    储存已被虚拟机加载的类信息、常量、静态变量、即时编译器后的代码数据。

运行时常量池:方法区的一部分

在Java虚拟机规范中：
    当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。











