buffer pool:缓存表数据与索引数据，把磁盘上的数据加载到缓冲池，避免每次访问都进行磁盘IO，起到加速访问的作用
预读:磁盘读写，并不是按需读取，而是按页读取，一次至少读一页数据（一般是4K），如果未来要读取的数据就在页中，
    就能够省去后续的磁盘IO，提高效率

传统的LRU是如何进行缓冲页管理:
    把入缓冲池的页放到LRU的头部，作为最近访问的元素，从而最晚被淘汰。这里又分两种情况：
    （1）页已经在缓冲池里，那就只做“移至”LRU头部的动作，而没有页被淘汰；
    （2）页不在缓冲池里，除了做“放入”LRU头部的动作，还要做“淘汰”LRU尾部页的动作

为啥MySQL不直接用传统LRU呢?
    （1）预读失效；
    （2）缓冲池污染；

预读失效:由于预读(Read-Ahead)，提前把页放入了缓冲池，但最终MySQL并没有从页中读取数据，称为预读失效
缓冲池污染:当某一个SQL语句，要批量扫描大量数据时，可能导致把缓冲池的所有页都替换出去，导致大量热数据被换出，
            MySQL性能急剧下降，这种情况叫缓冲池污染

mysql将LRU分为两个部分:默认7:3
    新生代(new sublist)7
    老生代(old sublist)3
    新老生代收尾相连，即：新生代的尾(tail)连接着老生代的头(head)；
    新页（例如被预读的页）加入缓冲池时，只加入到老生代头部：
    如果数据真正被读取（预读成功），才会加入到新生代的头部
    如果数据没有被读取，则会比新生代里的“热数据页”更早被淘汰出缓冲池
数据污染问题：
MySQL缓冲池加入了一个“老生代停留时间窗口”的机制：
（1）假设T=老生代停留时间窗口；
（2）插入老生代头部的页，即使立刻被访问，并不会立刻放入新生代头部；
（3）只有满足“被访问”并且“在老生代停留时间”大于T，才会被放入新生代头部；


