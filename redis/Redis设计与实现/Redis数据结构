1. sds字符串
    sds 数据结构：
        struct sdshdr {
            int len;//记录buf数组中已使用的字节数
            int free;//记录buf数组中未使用字节数
            char buf[];//字节数组
        }
2. 链表：
    2.1双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点复杂度O(1)
    2.2无环：头节点的prev和尾节点next都指向null
    2.3都带有头指针和尾指针
    2.4带链表长度计数器
3. 字典：类似Java HashMap
4. 跳跃表：是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问的目的
          Redis使用跳跃表作为有序集合键的底层实现之一，当有序集合数量多或者是字符长度较长时，redis
          使用跳跃表来作为有序集合的底层实现
5.整数集合：是集合键的底层实现之一（SADD），当集合键只是包含整数时，并且这个集合元素不多时，redis就使用
          整数集合键作为底层实现。
          intset(整数集合)数据结构：
           struct intset {
           //编码方式
            int encoding;
            //集合包含的元素数量
            int length;
            //保存元素的数组
            int content[];
           }
6.压缩列表：哈希键和列表键的底层实现之一，
            当一个哈希键（Hset）只包含少量的键值对，且每个键值对的键和值要么就是小正数值，
            要么就是较短的字符串时，redis会使用压缩列表作为哈希键的底层实现之一
            当一个列表键只包含少量列表项，并且每个项目要么是小整数，要么是短字符串，redis会使用压缩列表
            作为列表键的底层实现之一。
            压缩列表是由一系列特殊编码的连续内存快组成的顺序型数据结构。

redis通过引用计数器对数据对象进行内存垃圾回收。
redis中每个对象都有一个RedisObject结构表示，该结构如下：
    struct redisObject {
        int type;//类型，决定了对象类型
        int encoding;//编码，决定了使用的数据结构类型，即sds,hash,链表，压缩列表等
        T t;//指向底层的实现数据结构；
    }

对象：
1.字符串对象(string,set)：字符串对象的编码可以是int，raw,embstr;embstr 与raw编码一样会使用RedisObject结构
    和sdshdr数据结构来表示字符串，但是raw编码会通过调用两次内存分配函数分别创建RedisObject结构和sdshdr结构
    embstr通过一次内存分配来一空连续的内存空间，空间中包含了RedisObject和sdshdr结构

    字符串在redis中五种数据对象可以被其他数据对象嵌套的

2.列表对象(list,list)：列表对象的编码可以是ziplist和linkedlist，编码转换：
    2.1 列表对象保存的所有字符串长度都小于64字节
    2.2 列表对象保存的元素个数少于512个；不能满足这个两个条件的列表需要使用linkedlist编码，这两个
        条件是可以配置的，list-max-ziplist-value和list-max-ziplist-entries
3.哈希对象(hash,hset)：哈希对象的编码可以是ziplist和hashtable
    ziplist 作为哈希对象的编码时候，每当有新的键值对添加到哈希对象时，程序会先将保存键到压缩列表中，在保存值
        因此：保存同一对的节点总是紧挨着在一起，保存在键的节点前，保存值在后
             先添加的键值对在前
    hashtable编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：
        字典的每个键都是一个字符串对象，对象中保存了键值对的键
        字典的每个值都是一个字符串对象，对象中保存了键值对的值
    编码转换：
        哈希对象保存的所有键值对的键和值的字符长度都小于64字节；
        哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hastable编码；
        这两个条件是可以配置的，hash-max-ziplist-value和hash-max-ziplist-entries
4.集合对象(set,sadd)：集合的编码可以是intset和hashtable
    intset 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面
    hashtable 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象
    包含了一个集合元素，而字典的值则全部都被设置为null
    编码转换：
        集合对象的元素都是整数值
        集合对象保存的元素个数不超过255个；不满足的转为hashtable，其中第二个条件可以通过配置
        set-max-intset-entries
5.有序集合对象(zset,zset):有序集合的编码可以是ziplist和skiplist
        ziplist编码的压缩对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存
            第一个节点保存元素的成员(member),而第二个元素则保存元素的分数(score),集合内的列表元素按照
            分值大小排序，分值小的放在靠近表头，较大的靠近表尾。
        skiplist(跳跃表):在有序集合中跳跃表分值从小到大保存了所有集合元素，每个跳跃表保存了一个集合元素；
        编码转换：
            有序集合保存的元素数量小于128个；
            有序集合保存的所有元素成员的长度都小于64字节；
            不满足以上两个条件的转换为skiplist编码。
            这两个条件是可以配置的，zset-max-ziplist-value和zset-max-ziplist-entries

类型检测与命令多态：
    redis命令分为两种：
        1.其中一种命令对任何类型都有效，例如：del，expire,keys type等
        2.只能对特定类型的键执行 例如：
            set get appand strlen等只能对字符串键执行
            hdel hset hget hlen 等只能对哈希键执行
            rpush lpop linsert llen 只能对列表键执行
            sadd spop sinter scard 只能对集合键执行
            zadd zcard zrank zscore 只能对有序集合执行
    为了确保只有指定类型的键可以执行某些特定的命令，在执行一个特定类型的命令之前，redis会先检查
    输入键的类型是否正确，然后在决定是否执行给定的命令，其实现是通过RedisObject的type属性来实现：
        在执行一个类型命令之前，先检查输入数据库的键的值的对象是否为执行命令所需要的类型，如果是执行
        否则向客户端返回一个类型错误

          
