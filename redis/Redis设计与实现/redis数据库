数据库结构：
    struct redisServer{
        int dbnum;//服务器数据库数量，默认16个
        RedisDb[] redisDb;//db数组，每个db代表一个数据库
    }
    在服务器内部，客户端状态redisClient结构的db属性记录了客户端当前的目标数据库，指向具体的redisDb
    struct redisClient {
        RedisDb redisDb;//指向具体的redisdb
    }

    redisDb结构：
    struct redisDb {
        HashMap  hashMap;
    }

过期键的删除策略：
    1.定时删除：在设置键的过期时间的同时，创建一个定时器（Timer），让定时器在键的过期时间来临时，立刻执行删除
    2.惰性删除：放任不管，但是在获取的时候，判断是否过期，过期了删除，否则返回该键
    3.定期删除：每个一段时间对数据库进行一次检查，删除过期键

    在AOF、RDB和复制功能对过期键的处理
    1.生成RDB文件 ：在执行save或者bgsave命令创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期
        的键不会被保存到新创建的RDB文件中。
    2.载入RDB文件：
        如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件保存的键进行检查，未过期的被载入，否则
            忽略
        如果服务器以从服务器模式运行，那么在载入时，保存所有的键，不论是否过期。不过因为主从服务器在进行数据同步
        的时候，从服务器的数据库就会被清空。
    3.aof文件写入：如果某个键过期了但是还没有被删除，在执行删除的时候，会在aof文件中显示的添加一条del语句。
    4.aof重写：在aof重写过程中，程序会对数据库进行检查，如果已经过期了就不会被保存到aof文件中。

RDB文件：
    生产RDB文件的命令有两个：save(同步有阻塞),bgsave（异步没有阻塞）；这两个命令都是调用的同一个函数，只不过
        后者相当于开了一个线程在使用；
    载入RDB文件：在服务启动时，检测到存在RDB文件自动执行；
        如果服务器开启了aof持久化功能，那么服务器会优先使用aof文件来进行还原数据，只有在aof持久化功能处于
        关闭状态时，服务器才会使用RDB文件来还原数据库状态。
    自动间隔性保存：通过配置文件定时调用bgsave命令：通过周期性调用，每次调用成功保存更新次数和最后更新时间
    RDB文件结构：
        1.五个字节的'REDIS'字符串
        2.四个字节的版本号(db_version)
        3.数据库（当数据库没有键值对时，没有）
        4.一个字节的EOF常量
        5.八个字节的校验和(check_num)
AOF文件：
    rdb文件保存的是键值对，而aof文件则是把服务器执行的命令保存在aof文件中 例如
        set msg 'hello' 在rdb文件里保存的是 msg->hello,而在aof文件里保存的是 set msg 'hello'，
        也就说aof文件中的命令都是以请求协议格式保存

    aof持久化功能分为三个 追加（append），文件写入，文件同步（sync）三个步骤
        追加：服务器写完命令后，会议协议格式将命令执行写命令追加到aof_buf缓冲区的末尾；
        写入：服务器在执行写命令，会有一些内容被追加到aof_buf中，然后它在调用flushAppendOnlyFile函数，
             考虑把aof_buf缓冲区的内容写入到aof文件中
        同步：把aof_buf缓冲区的内容写入到aof文件中

        flushAppendOnlyFile函数的行为根据配置来的：
            always：将aof_buf缓冲区中的所有内容写入并同步到aof文件中
            everysec: 将aof_buf缓冲区中的所有内容写入到aof文件中，每隔一秒钟同步一次到aof文件中
            no:将aof_buf缓冲区中的所有内容写入到aof文件中，但并不对AOF文件进行同步，何时同步由操作系统决定
    aof的载入：
        1.创建一个没有网络连接的伪客户端
        2.从AOF文件中解析出命令
        3.执行命令
        4.重复执行2，3直到AOF文件命令都写完
    aof的重写：通过创建一个新的AOF文件来代替旧的文件，新的文件通过整理合并旧的文件命令达到简化体积，关键是通过
              合并命令；例如：rpush list 'a'  rpush list 'b' rpush list 'c',重写时可以将三条命令合并
              为一条   rpush list 'a' 'b' 'c';
              首先通过读取数据库现在的键值对，然后用一条命令去替代之前的多条命令。
        阻塞重写：redis服务器直接读取数据库存在的键值对情况写入到新的aof文件中，过程是阻塞的
        后台重写：redis重写fork一个子进程（不是线程），好处：
                子进程进行AOF重写期间，服务器可以继续处理命令请求。
                子进程带有服务器的数据副本，使用子进程，可以避免多线程的竞态条件，保证数据安全
                redis设置了AOF重写缓冲区，当redis执行完成一个写命令后，它会将这个写命令发送给AOF缓冲区和
                    AOF重写缓冲区
redis 请求协议：
    RESP是一种序列化协议，支持以下类型：简单字符串（sample strings），错误（Errors），
        整型（integers），块字符串（bulk strings）和数组（arrays）。
    在RESP里，数据类型是第一个字节决定的：
    第一个字节是“+”代表简单字符串类型。
    第一个字节是“-”代表错误类型。
    第一个字节是“:”代表整型。
    第一个字节是“$”代表块字符串。
    第一个自己是“*”代表数组。
    RESP能用一个特殊的块字符串代表NULL。RESP协议不同的部分用“\r\n”(CRLF)结尾。

命令请求过程：
    1.客户端向服务端发送命令请求
    2.服务端接收请求并执行命令，返回命令回复
    3.客户端接收命令回复

redis服务端启动过程：
    1.创建redisServer类型实例，并给属性附上默认值（initServerConfig）
    2.加载配置
    3.初始化数据结构（initServer）
    4.还原数据状态（加载aof文件或者是RDB文件）
    5.执行循环事件（loop）




